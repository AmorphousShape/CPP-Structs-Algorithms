<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPP-Structs-Algorithms: RBTree&lt; keyType, valueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CPP-Structs-Algorithms
   </div>
   <div id="projectbrief">This is a collection of some C++ data structures and algorithms that are typically not included in standard libraries.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_r_b_tree.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_r_b_tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RBTree&lt; keyType, valueType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements a Red-Black Tree.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="datastructs_8hpp_source.html">datastructs.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0626b6bbc90feb0f2cb5923b3ba71381" id="r_a0626b6bbc90feb0f2cb5923b3ba71381"><td class="memItemLeft" align="right" valign="top"><a id="a0626b6bbc90feb0f2cb5923b3ba71381" name="a0626b6bbc90feb0f2cb5923b3ba71381"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RBTree</b> ()</td></tr>
<tr class="memdesc:a0626b6bbc90feb0f2cb5923b3ba71381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a0626b6bbc90feb0f2cb5923b3ba71381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c5eeaf33f1e6ed0ddf3d196ac38bad" id="r_ad1c5eeaf33f1e6ed0ddf3d196ac38bad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1c5eeaf33f1e6ed0ddf3d196ac38bad">RBTree</a> (keyType k, valueType v)</td></tr>
<tr class="memdesc:ad1c5eeaf33f1e6ed0ddf3d196ac38bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tree with a single node with key k and value v.  <br /></td></tr>
<tr class="separator:ad1c5eeaf33f1e6ed0ddf3d196ac38bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de58f2af6995d12cad5bcf94699e3d6" id="r_a3de58f2af6995d12cad5bcf94699e3d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3de58f2af6995d12cad5bcf94699e3d6">RBTree</a> (keyType *k, valueType *v, int s)</td></tr>
<tr class="memdesc:a3de58f2af6995d12cad5bcf94699e3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tree with arrays k and v as the insert values and size = s.  <br /></td></tr>
<tr class="separator:a3de58f2af6995d12cad5bcf94699e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b508e8251a3d96dde94e88a40980a1" id="r_a60b508e8251a3d96dde94e88a40980a1"><td class="memItemLeft" align="right" valign="top"><a id="a60b508e8251a3d96dde94e88a40980a1" name="a60b508e8251a3d96dde94e88a40980a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RBTree</b> (const <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt; &amp;src)</td></tr>
<tr class="memdesc:a60b508e8251a3d96dde94e88a40980a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deep copy) <br /></td></tr>
<tr class="separator:a60b508e8251a3d96dde94e88a40980a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766b03d225fe977fd52ffcf24998bbf2" id="r_a766b03d225fe977fd52ffcf24998bbf2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a766b03d225fe977fd52ffcf24998bbf2">~RBTree</a> ()</td></tr>
<tr class="memdesc:a766b03d225fe977fd52ffcf24998bbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a766b03d225fe977fd52ffcf24998bbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e10deb59bf471f7ad82c153cd950e0e" id="r_a0e10deb59bf471f7ad82c153cd950e0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e10deb59bf471f7ad82c153cd950e0e">operator=</a> (const <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt; &amp;R)</td></tr>
<tr class="memdesc:a0e10deb59bf471f7ad82c153cd950e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy equals operator.  <br /></td></tr>
<tr class="separator:a0e10deb59bf471f7ad82c153cd950e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f964115e4f37b0150c64b2bb73132ef" id="r_a1f964115e4f37b0150c64b2bb73132ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f964115e4f37b0150c64b2bb73132ef">preorder</a> (ostream &amp;out)</td></tr>
<tr class="memdesc:a1f964115e4f37b0150c64b2bb73132ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the preorder traversal of the tree.  <br /></td></tr>
<tr class="separator:a1f964115e4f37b0150c64b2bb73132ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a342a6c017131baf42765f6fe6361" id="r_ac58a342a6c017131baf42765f6fe6361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac58a342a6c017131baf42765f6fe6361">inorder</a> (ostream &amp;out)</td></tr>
<tr class="memdesc:ac58a342a6c017131baf42765f6fe6361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the inorder traversal of the tree.  <br /></td></tr>
<tr class="separator:ac58a342a6c017131baf42765f6fe6361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e754ed0139aaea16268b5debb8c17e2" id="r_a9e754ed0139aaea16268b5debb8c17e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e754ed0139aaea16268b5debb8c17e2">postorder</a> (ostream &amp;out)</td></tr>
<tr class="memdesc:a9e754ed0139aaea16268b5debb8c17e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the postorder traversal of the tree.  <br /></td></tr>
<tr class="separator:a9e754ed0139aaea16268b5debb8c17e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7281ceb79c0c60a6f94b7ee9648e988a" id="r_a7281ceb79c0c60a6f94b7ee9648e988a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7281ceb79c0c60a6f94b7ee9648e988a">printk</a> (int k, ostream &amp;out)</td></tr>
<tr class="memdesc:a7281ceb79c0c60a6f94b7ee9648e988a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the K smallest elements of the tree.  <br /></td></tr>
<tr class="separator:a7281ceb79c0c60a6f94b7ee9648e988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641fbb2ef33d68c965204e19c9ea1b86" id="r_a641fbb2ef33d68c965204e19c9ea1b86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a641fbb2ef33d68c965204e19c9ea1b86">size</a> ()</td></tr>
<tr class="memdesc:a641fbb2ef33d68c965204e19c9ea1b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the tree.  <br /></td></tr>
<tr class="separator:a641fbb2ef33d68c965204e19c9ea1b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34631a7f9e8f543e9a054f82f4b62a83" id="r_a34631a7f9e8f543e9a054f82f4b62a83"><td class="memItemLeft" align="right" valign="top">valueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34631a7f9e8f543e9a054f82f4b62a83">search</a> (keyType k)</td></tr>
<tr class="memdesc:a34631a7f9e8f543e9a054f82f4b62a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the tree for key k and returns a pointer to the node's value.  <br /></td></tr>
<tr class="separator:a34631a7f9e8f543e9a054f82f4b62a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb4cecf25b152dc8b18f694f81a57ef" id="r_affb4cecf25b152dc8b18f694f81a57ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affb4cecf25b152dc8b18f694f81a57ef">insert</a> (keyType k, valueType v)</td></tr>
<tr class="memdesc:affb4cecf25b152dc8b18f694f81a57ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node with key k and value v into the tree.  <br /></td></tr>
<tr class="separator:affb4cecf25b152dc8b18f694f81a57ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001264a0bb5dca50c66bb7efbca888f1" id="r_a001264a0bb5dca50c66bb7efbca888f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a001264a0bb5dca50c66bb7efbca888f1">remove</a> (keyType k)</td></tr>
<tr class="memdesc:a001264a0bb5dca50c66bb7efbca888f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node with key k from the tree.  <br /></td></tr>
<tr class="separator:a001264a0bb5dca50c66bb7efbca888f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23fc8853cfae6b260ae69a79429d3e7" id="r_ae23fc8853cfae6b260ae69a79429d3e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae23fc8853cfae6b260ae69a79429d3e7">rank</a> (keyType k)</td></tr>
<tr class="memdesc:ae23fc8853cfae6b260ae69a79429d3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the node with key k.  <br /></td></tr>
<tr class="separator:ae23fc8853cfae6b260ae69a79429d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d7087fc666f97b1f3f4f66192ced6c" id="r_a09d7087fc666f97b1f3f4f66192ced6c"><td class="memItemLeft" align="right" valign="top">keyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d7087fc666f97b1f3f4f66192ced6c">select</a> (int k)</td></tr>
<tr class="memdesc:a09d7087fc666f97b1f3f4f66192ced6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Kth smallest element in the tree.  <br /></td></tr>
<tr class="separator:a09d7087fc666f97b1f3f4f66192ced6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a0372b080a5307311f79751deafc87" id="r_ae2a0372b080a5307311f79751deafc87"><td class="memItemLeft" align="right" valign="top">keyType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2a0372b080a5307311f79751deafc87">successor</a> (keyType k)</td></tr>
<tr class="memdesc:ae2a0372b080a5307311f79751deafc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the successor of the node with key k and returns a pointer to its key.  <br /></td></tr>
<tr class="separator:ae2a0372b080a5307311f79751deafc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc14632bf7705dc544ff6a473f80d07" id="r_a5fc14632bf7705dc544ff6a473f80d07"><td class="memItemLeft" align="right" valign="top">keyType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fc14632bf7705dc544ff6a473f80d07">predecessor</a> (keyType k)</td></tr>
<tr class="memdesc:a5fc14632bf7705dc544ff6a473f80d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the predecessor of the node with key k and returns a pointer to its key.  <br /></td></tr>
<tr class="separator:a5fc14632bf7705dc544ff6a473f80d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename keyType, typename valueType&gt;<br />
class RBTree&lt; keyType, valueType &gt;</div><p>Implements a Red-Black Tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">keyType</td><td>The type of key stored in the tree </td></tr>
    <tr><td class="paramname">valueType</td><td>The type of value stored in the tree</td></tr>
  </table>
  </dd>
</dl>
<p>This class implements a Red-Black Tree, a self-balancing binary search tree. It maintains balance using rotations and recoloring during insertions and deletions, ensuring efficient operations with a time complexity of O(log n).</p>
<p>The tree has the following properties:</p><ul>
<li>Each node has a color (Red or Black).</li>
<li>The root node is always Black.</li>
<li>Red nodes cannot have Red children (no two consecutive Red nodes).</li>
<li>Every path from a node to its descendant nil nodes has the same number of Black nodes (Black height).</li>
<li>The nil node (a sentinel node representing the end of the tree) is always Black.</li>
</ul>
<p>These properties ensure that the tree remains approximately balanced, making it suitable for applications requiring fast lookups, insertions, and deletions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1c5eeaf33f1e6ed0ddf3d196ac38bad" name="ad1c5eeaf33f1e6ed0ddf3d196ac38bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c5eeaf33f1e6ed0ddf3d196ac38bad">&#9670;&#160;</a></span>RBTree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;<a class="el" href="class_r_b_tree.html">::RBTree</a> </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueType</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tree with a single node with key k and value v. </p>
<p>This constructor initializes the tree with a single node with the given key and value. The nil node is created, and the root is set to the new node. The color of the root is set to Black. Time complexity: O(1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the root node </td></tr>
    <tr><td class="paramname">v</td><td>The value of the root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de58f2af6995d12cad5bcf94699e3d6" name="a3de58f2af6995d12cad5bcf94699e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de58f2af6995d12cad5bcf94699e3d6">&#9670;&#160;</a></span>RBTree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;<a class="el" href="class_r_b_tree.html">::RBTree</a> </td>
          <td>(</td>
          <td class="paramtype">keyType *</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueType *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a tree with arrays k and v as the insert values and size = s. </p>
<p>This constructor initializes the tree with the given arrays of keys and values. It creates a nil node and inserts each key-value pair into the tree. The root is set to nil initially. Time complexity: O(s)</p>
<dl class="section note"><dt>Note</dt><dd>If s is larger than the size of either array, this will cause a segmentation fault. Any s smaller than the size of either array will work up to the specified index, but the rest of the array will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The array of keys to insert </td></tr>
    <tr><td class="paramname">v</td><td>The array of values to insert </td></tr>
    <tr><td class="paramname">s</td><td>The size of the arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a766b03d225fe977fd52ffcf24998bbf2" name="a766b03d225fe977fd52ffcf24998bbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766b03d225fe977fd52ffcf24998bbf2">&#9670;&#160;</a></span>~RBTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::~<a class="el" href="class_r_b_tree.html">RBTree</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This destructor deletes the tree by calling the cascade function on the root node. The cascade function recursively deletes all nodes in the tree. Time complexity: O(size) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac58a342a6c017131baf42765f6fe6361" name="ac58a342a6c017131baf42765f6fe6361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58a342a6c017131baf42765f6fe6361">&#9670;&#160;</a></span>inorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::inorder </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the inorder traversal of the tree. </p>
<p>This function prints the inorder traversal of the tree. It calls the root's inorder function, which prints the nodes in inorder. Time complexity: O(n) </p>

</div>
</div>
<a id="affb4cecf25b152dc8b18f694f81a57ef" name="affb4cecf25b152dc8b18f694f81a57ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb4cecf25b152dc8b18f694f81a57ef">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueType</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new node with key k and value v into the tree. </p>
<p>This function inserts a new node with key k and value v into the tree. It first creates a new node and sets its size to 1. Then, it traverses the tree to find the correct position for the new node. Finally, it calls the insertFixTree function to restore the Red-Black Tree properties. Time complexity: O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the new node </td></tr>
    <tr><td class="paramname">v</td><td>The value of the new node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e10deb59bf471f7ad82c153cd950e0e" name="a0e10deb59bf471f7ad82c153cd950e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e10deb59bf471f7ad82c153cd950e0e">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt; &amp; <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy equals operator. </p>
<p>This operator assigns the values of the source tree to the current tree. It first deletes the current tree and then copies the values from the source tree. Time complexity: O(n), n = R.root-&gt;size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>The source tree to copy from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current tree </dd></dl>

</div>
</div>
<a id="a9e754ed0139aaea16268b5debb8c17e2" name="a9e754ed0139aaea16268b5debb8c17e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e754ed0139aaea16268b5debb8c17e2">&#9670;&#160;</a></span>postorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::postorder </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the postorder traversal of the tree. </p>
<p>This function prints the postorder traversal of the tree. It calls the root's postorder function, which prints the nodes in postorder. Time complexity: O(n) </p>

</div>
</div>
<a id="a5fc14632bf7705dc544ff6a473f80d07" name="a5fc14632bf7705dc544ff6a473f80d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc14632bf7705dc544ff6a473f80d07">&#9670;&#160;</a></span>predecessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">keyType * <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::predecessor </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the predecessor of the node with key k and returns a pointer to its key. </p>
<p>This function finds the predecessor of the node with key k. The predecessor is the largest node in the left subtree. If the left child is null, it returns nullptr. Time complexity: O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the node whose predecessor is to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the key of the predecessor node, or nullptr if there is no predecessor </dd></dl>

</div>
</div>
<a id="a1f964115e4f37b0150c64b2bb73132ef" name="a1f964115e4f37b0150c64b2bb73132ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f964115e4f37b0150c64b2bb73132ef">&#9670;&#160;</a></span>preorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::preorder </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the preorder traversal of the tree. </p>
<p>This function prints the preorder traversal of the tree. It calls the root's preorder function, which prints the nodes in preorder. Time complexity: O(n) </p>

</div>
</div>
<a id="a7281ceb79c0c60a6f94b7ee9648e988a" name="a7281ceb79c0c60a6f94b7ee9648e988a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7281ceb79c0c60a6f94b7ee9648e988a">&#9670;&#160;</a></span>printk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::printk </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the K smallest elements of the tree. </p>
<p>This function prints the K smallest elements of the tree. It calls the root's printk function, which prints the K smallest elements in preorder traversal. Time complexity: O(k + lg(size)) </p>

</div>
</div>
<a id="ae23fc8853cfae6b260ae69a79429d3e7" name="ae23fc8853cfae6b260ae69a79429d3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23fc8853cfae6b260ae69a79429d3e7">&#9670;&#160;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::rank </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the node with key k. </p>
<p>This function returns the rank of the node with key k. The rank is the number of nodes with keys less than k. If the key is not found, it returns 0. Time complexity: O(lg(root-&gt;size)) </p>

</div>
</div>
<a id="a001264a0bb5dca50c66bb7efbca888f1" name="a001264a0bb5dca50c66bb7efbca888f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001264a0bb5dca50c66bb7efbca888f1">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the node with key k from the tree. </p>
<p>This function removes the node with key k from the tree. It first searches for the node with key k. If the node is found, it removes it and restores the Red-Black Tree properties. Time complexity: O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the node to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the node was removed, 0 if the node was not found. </dd></dl>

</div>
</div>
<a id="a34631a7f9e8f543e9a054f82f4b62a83" name="a34631a7f9e8f543e9a054f82f4b62a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34631a7f9e8f543e9a054f82f4b62a83">&#9670;&#160;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">valueType * <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::search </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the tree for key k and returns a pointer to the node's value. </p>
<p>This function searches the tree for key k and returns a pointer to the node's value. If the key is not found, it returns nullptr. Time complexity: O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the value of the node with key k, or nullptr if the key is not found </dd></dl>

</div>
</div>
<a id="a09d7087fc666f97b1f3f4f66192ced6c" name="a09d7087fc666f97b1f3f4f66192ced6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d7087fc666f97b1f3f4f66192ced6c">&#9670;&#160;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">keyType <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::select </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Kth smallest element in the tree. </p>
<dl class="section note"><dt>Note</dt><dd>This function currently is delegated to a function in the Node but should be migrated to the tree. This was done due to the original project specifications.</dd></dl>
<p>This function returns the Kth smallest element in the tree. The Kth smallest element is the node with rank k. If k is out of bounds or not found, it returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The rank of the smallest element to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the Kth smallest element in the tree, or nullptr if k is out of bounds </dd></dl>

</div>
</div>
<a id="a641fbb2ef33d68c965204e19c9ea1b86" name="a641fbb2ef33d68c965204e19c9ea1b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641fbb2ef33d68c965204e19c9ea1b86">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the tree </dd></dl>

</div>
</div>
<a id="ae2a0372b080a5307311f79751deafc87" name="ae2a0372b080a5307311f79751deafc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a0372b080a5307311f79751deafc87">&#9670;&#160;</a></span>successor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">keyType * <a class="el" href="class_r_b_tree.html">RBTree</a>&lt; keyType, valueType &gt;::successor </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the successor of the node with key k and returns a pointer to its key. </p>
<p>This function finds the successor of the node with key k. The successor is the smallest node in the right subtree. If the right child is null, it returns nullptr. Time complexity: O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the node whose successor is to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the key of the successor node, or nullptr if there is no successor </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/jace/Documents/GitHub/CPP-Structs-Algorithms/<a class="el" href="datastructs_8hpp_source.html">datastructs.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_r_b_tree.html">RBTree</a></li>
    <li class="footer">Generated on Sat Apr 26 2025 17:17:25 for CPP-Structs-Algorithms by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
