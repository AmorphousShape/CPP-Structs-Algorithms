<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPP-Structs-Algorithms: RBNode&lt; keyType, valueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CPP-Structs-Algorithms
   </div>
   <div id="projectbrief">This is a collection of some C++ data structures and algorithms that are typically not included in standard libraries.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_r_b_node.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_r_b_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RBNode&lt; keyType, valueType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Node for a Red-Black Tree.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="datastructs_8hpp_source.html">datastructs.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae493be679053a615302a89a2120115c0" id="r_ae493be679053a615302a89a2120115c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae493be679053a615302a89a2120115c0">RBNode</a> ()</td></tr>
<tr class="memdesc:ae493be679053a615302a89a2120115c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:ae493be679053a615302a89a2120115c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c87bd7226507202c74d24919d55cf0" id="r_a05c87bd7226507202c74d24919d55cf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05c87bd7226507202c74d24919d55cf0">RBNode</a> (keyType k, valueType v)</td></tr>
<tr class="memdesc:a05c87bd7226507202c74d24919d55cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a node with specified key and value.  <br /></td></tr>
<tr class="separator:a05c87bd7226507202c74d24919d55cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ca7563c657f088a1adb4367d14b610" id="r_ad5ca7563c657f088a1adb4367d14b610"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5ca7563c657f088a1adb4367d14b610">RBNode</a> (bool nilCon)</td></tr>
<tr class="memdesc:ad5ca7563c657f088a1adb4367d14b610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a nil node.  <br /></td></tr>
<tr class="separator:ad5ca7563c657f088a1adb4367d14b610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50899f501058ad38584023054d6ea9eb" id="r_a50899f501058ad38584023054d6ea9eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50899f501058ad38584023054d6ea9eb">RBNode</a> (keyType k, valueType v, color setc, int s, <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; *parent)</td></tr>
<tr class="memdesc:a50899f501058ad38584023054d6ea9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a node with specified key, value, color, size, and parent.  <br /></td></tr>
<tr class="separator:a50899f501058ad38584023054d6ea9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3438a3e8947ee19923406fd7885c058" id="r_ad3438a3e8947ee19923406fd7885c058"><td class="memItemLeft" align="right" valign="top"><a id="ad3438a3e8947ee19923406fd7885c058" name="ad3438a3e8947ee19923406fd7885c058"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RBNode</b> (const <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; &amp;src)</td></tr>
<tr class="memdesc:ad3438a3e8947ee19923406fd7885c058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (deep copy) <br /></td></tr>
<tr class="separator:ad3438a3e8947ee19923406fd7885c058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6455153f40a6b4c14cc9a655450d4533" id="r_a6455153f40a6b4c14cc9a655450d4533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6455153f40a6b4c14cc9a655450d4533">~RBNode</a> ()</td></tr>
<tr class="memdesc:a6455153f40a6b4c14cc9a655450d4533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a6455153f40a6b4c14cc9a655450d4533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfc053a89b7e3eecf5ea1d93b60d460" id="r_acdfc053a89b7e3eecf5ea1d93b60d460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdfc053a89b7e3eecf5ea1d93b60d460">cascade</a> (<a class="el" href="class_r_b_node.html">RBNode</a> *nil)</td></tr>
<tr class="memdesc:acdfc053a89b7e3eecf5ea1d93b60d460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a node and all its children.  <br /></td></tr>
<tr class="separator:acdfc053a89b7e3eecf5ea1d93b60d460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7432e8b0ec24eaecd2c5ae693c0ae6c" id="r_ad7432e8b0ec24eaecd2c5ae693c0ae6c"><td class="memItemLeft" align="right" valign="top"><a id="ad7432e8b0ec24eaecd2c5ae693c0ae6c" name="ad7432e8b0ec24eaecd2c5ae693c0ae6c"></a>
<a class="el" href="class_r_b_node.html">RBNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_r_b_node.html">RBNode</a> R)</td></tr>
<tr class="memdesc:ad7432e8b0ec24eaecd2c5ae693c0ae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy equals operator. <br /></td></tr>
<tr class="separator:ad7432e8b0ec24eaecd2c5ae693c0ae6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b21a1c9b6cd5e98eed5339cefee6aa" id="r_a09b21a1c9b6cd5e98eed5339cefee6aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b21a1c9b6cd5e98eed5339cefee6aa">preorder</a> (std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a09b21a1c9b6cd5e98eed5339cefee6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the preorder traversal of the tree.  <br /></td></tr>
<tr class="separator:a09b21a1c9b6cd5e98eed5339cefee6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db4aa6a00a85a2f73a6e3af6323782a" id="r_a6db4aa6a00a85a2f73a6e3af6323782a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6db4aa6a00a85a2f73a6e3af6323782a">inorder</a> (std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a6db4aa6a00a85a2f73a6e3af6323782a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the inorder traversal of the tree.  <br /></td></tr>
<tr class="separator:a6db4aa6a00a85a2f73a6e3af6323782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b99d97ef8b4747bfc7a1cdc9fabf66f" id="r_a8b99d97ef8b4747bfc7a1cdc9fabf66f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b99d97ef8b4747bfc7a1cdc9fabf66f">postorder</a> (std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a8b99d97ef8b4747bfc7a1cdc9fabf66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the postorder traversal of the tree.  <br /></td></tr>
<tr class="separator:a8b99d97ef8b4747bfc7a1cdc9fabf66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec8e7b69ad9f75c51785630701d01dd" id="r_a0ec8e7b69ad9f75c51785630701d01dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec8e7b69ad9f75c51785630701d01dd">printNode</a> (std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a0ec8e7b69ad9f75c51785630701d01dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the node's key.  <br /></td></tr>
<tr class="separator:a0ec8e7b69ad9f75c51785630701d01dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d79602d5ae78941178669947634126" id="r_af4d79602d5ae78941178669947634126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4d79602d5ae78941178669947634126">printk</a> (int &amp;k, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:af4d79602d5ae78941178669947634126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the K smallest elements of the subtree rooted at this node.  <br /></td></tr>
<tr class="separator:af4d79602d5ae78941178669947634126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91795a969ff5f24d7a07cbde4fde5d2a" id="r_a91795a969ff5f24d7a07cbde4fde5d2a"><td class="memItemLeft" align="right" valign="top">valueType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91795a969ff5f24d7a07cbde4fde5d2a">searchValue</a> (keyType k)</td></tr>
<tr class="memdesc:a91795a969ff5f24d7a07cbde4fde5d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the node with key k and returns a pointer to the value.  <br /></td></tr>
<tr class="separator:a91795a969ff5f24d7a07cbde4fde5d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecf6a080a7480fdce09e79fb3fada21" id="r_acecf6a080a7480fdce09e79fb3fada21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acecf6a080a7480fdce09e79fb3fada21">searchNode</a> (keyType k)</td></tr>
<tr class="memdesc:acecf6a080a7480fdce09e79fb3fada21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the subtree rooted at this node for the node with key k.  <br /></td></tr>
<tr class="separator:acecf6a080a7480fdce09e79fb3fada21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497702bdad08496c307e538fbaa2f1eb" id="r_a497702bdad08496c307e538fbaa2f1eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a497702bdad08496c307e538fbaa2f1eb">predecessor</a> ()</td></tr>
<tr class="memdesc:a497702bdad08496c307e538fbaa2f1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the predecessor of the node.  <br /></td></tr>
<tr class="separator:a497702bdad08496c307e538fbaa2f1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00233287e0c6b69900144aeea0e8fab6" id="r_a00233287e0c6b69900144aeea0e8fab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00233287e0c6b69900144aeea0e8fab6">min</a> ()</td></tr>
<tr class="memdesc:a00233287e0c6b69900144aeea0e8fab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest node of the subtree rooted at this node.  <br /></td></tr>
<tr class="separator:a00233287e0c6b69900144aeea0e8fab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd4a3d39d4bfe6f4338ee333ea5cf07" id="r_a4fd4a3d39d4bfe6f4338ee333ea5cf07"><td class="memItemLeft" align="right" valign="top">keyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fd4a3d39d4bfe6f4338ee333ea5cf07">select</a> (int k)</td></tr>
<tr class="memdesc:a4fd4a3d39d4bfe6f4338ee333ea5cf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Kth smallest element in the subtree rooted at this node.  <br /></td></tr>
<tr class="separator:a4fd4a3d39d4bfe6f4338ee333ea5cf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7f27b3f5a51191ef282c85150e086e0d" id="r_a7f27b3f5a51191ef282c85150e086e0d"><td class="memItemLeft" align="right" valign="top"><a id="a7f27b3f5a51191ef282c85150e086e0d" name="a7f27b3f5a51191ef282c85150e086e0d"></a>
keyType *&#160;</td><td class="memItemRight" valign="bottom"><b>key</b></td></tr>
<tr class="memdesc:a7f27b3f5a51191ef282c85150e086e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key of the node. <br /></td></tr>
<tr class="separator:a7f27b3f5a51191ef282c85150e086e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af48857a259820580b889edb9d6cd67" id="r_a6af48857a259820580b889edb9d6cd67"><td class="memItemLeft" align="right" valign="top"><a id="a6af48857a259820580b889edb9d6cd67" name="a6af48857a259820580b889edb9d6cd67"></a>
valueType *&#160;</td><td class="memItemRight" valign="bottom"><b>val</b></td></tr>
<tr class="memdesc:a6af48857a259820580b889edb9d6cd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the node. <br /></td></tr>
<tr class="separator:a6af48857a259820580b889edb9d6cd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fed95f84d9c4f3ea5bf6d1827ede1cb" id="r_a3fed95f84d9c4f3ea5bf6d1827ede1cb"><td class="memItemLeft" align="right" valign="top"><a id="a3fed95f84d9c4f3ea5bf6d1827ede1cb" name="a3fed95f84d9c4f3ea5bf6d1827ede1cb"></a>
<a class="el" href="class_r_b_node.html">RBNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>l</b></td></tr>
<tr class="memdesc:a3fed95f84d9c4f3ea5bf6d1827ede1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The left child of the node. <br /></td></tr>
<tr class="separator:a3fed95f84d9c4f3ea5bf6d1827ede1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340ed469e909840daa77a9be0b035726" id="r_a340ed469e909840daa77a9be0b035726"><td class="memItemLeft" align="right" valign="top"><a id="a340ed469e909840daa77a9be0b035726" name="a340ed469e909840daa77a9be0b035726"></a>
<a class="el" href="class_r_b_node.html">RBNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>r</b></td></tr>
<tr class="memdesc:a340ed469e909840daa77a9be0b035726"><td class="mdescLeft">&#160;</td><td class="mdescRight">The right child of the node. <br /></td></tr>
<tr class="separator:a340ed469e909840daa77a9be0b035726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaa0ed79684c8e2f161e7de837ce219" id="r_acdaa0ed79684c8e2f161e7de837ce219"><td class="memItemLeft" align="right" valign="top"><a id="acdaa0ed79684c8e2f161e7de837ce219" name="acdaa0ed79684c8e2f161e7de837ce219"></a>
<a class="el" href="class_r_b_node.html">RBNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>p</b></td></tr>
<tr class="memdesc:acdaa0ed79684c8e2f161e7de837ce219"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent of the node. <br /></td></tr>
<tr class="separator:acdaa0ed79684c8e2f161e7de837ce219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148eefaa40d5d08ba6a504e95ff19911" id="r_a148eefaa40d5d08ba6a504e95ff19911"><td class="memItemLeft" align="right" valign="top"><a id="a148eefaa40d5d08ba6a504e95ff19911" name="a148eefaa40d5d08ba6a504e95ff19911"></a>
color&#160;</td><td class="memItemRight" valign="bottom"><b>c</b></td></tr>
<tr class="memdesc:a148eefaa40d5d08ba6a504e95ff19911"><td class="mdescLeft">&#160;</td><td class="mdescRight">The color of the node. <br /></td></tr>
<tr class="separator:a148eefaa40d5d08ba6a504e95ff19911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdf75378d3b69502ea42c97d3d6a50a" id="r_a2bdf75378d3b69502ea42c97d3d6a50a"><td class="memItemLeft" align="right" valign="top"><a id="a2bdf75378d3b69502ea42c97d3d6a50a" name="a2bdf75378d3b69502ea42c97d3d6a50a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="memdesc:a2bdf75378d3b69502ea42c97d3d6a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the subtree rooted at this node. <br /></td></tr>
<tr class="separator:a2bdf75378d3b69502ea42c97d3d6a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename keyType, typename valueType&gt;<br />
class RBNode&lt; keyType, valueType &gt;</div><p>Node for a Red-Black Tree. </p>
<p>This class represents a node in a Red-Black Tree. It contains pointers to its left and right children, its parent, and its key and value. It also contains the color of the node (Red or Black) and the size of the subtree rooted at this node.</p>
<p>This class also has all of its elements set to public. This is because it is not intended to be used on its own; rather, it is for use by the <a class="el" href="class_r_b_tree.html" title="Implements a Red-Black Tree.">RBTree</a> class, which requires direct access to the node's elements to avoid unnecessary function calls.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">keyType</td><td>The type of key stored in the node </td></tr>
    <tr><td class="paramname">valueType</td><td>The type of value stored in the node </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae493be679053a615302a89a2120115c0" name="ae493be679053a615302a89a2120115c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae493be679053a615302a89a2120115c0">&#9670;&#160;</a></span>RBNode() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;<a class="el" href="class_r_b_node.html">::RBNode</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the node with default values. The key and value pointers are dynamically allocated. Color is set to Red. </p>

</div>
</div>
<a id="a05c87bd7226507202c74d24919d55cf0" name="a05c87bd7226507202c74d24919d55cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c87bd7226507202c74d24919d55cf0">&#9670;&#160;</a></span>RBNode() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;<a class="el" href="class_r_b_node.html">::RBNode</a> </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueType</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a node with specified key and value. </p>
<p>Initializes the node with the specified key and value. The color is set to Red, size is set to 1, and relatives are set to null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the node </td></tr>
    <tr><td class="paramname">v</td><td>The value of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5ca7563c657f088a1adb4367d14b610" name="ad5ca7563c657f088a1adb4367d14b610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ca7563c657f088a1adb4367d14b610">&#9670;&#160;</a></span>RBNode() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;<a class="el" href="class_r_b_node.html">::RBNode</a> </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nilCon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a nil node. </p>
<p>Initializes the node as a nil node. The key and value pointers are set to null, and the color is set to Black.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nilCon</td><td>A boolean value to indicate that this is a nil node. The value is not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50899f501058ad38584023054d6ea9eb" name="a50899f501058ad38584023054d6ea9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50899f501058ad38584023054d6ea9eb">&#9670;&#160;</a></span>RBNode() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;<a class="el" href="class_r_b_node.html">::RBNode</a> </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueType</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color</td>          <td class="paramname"><span class="paramname"><em>setc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a node with specified key, value, color, size, and parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the node </td></tr>
    <tr><td class="paramname">v</td><td>The value of the node </td></tr>
    <tr><td class="paramname">setc</td><td>The color of the node </td></tr>
    <tr><td class="paramname">s</td><td>The size of the subtree rooted at this node </td></tr>
    <tr><td class="paramname">parent</td><td>The parent of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6455153f40a6b4c14cc9a655450d4533" name="a6455153f40a6b4c14cc9a655450d4533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6455153f40a6b4c14cc9a655450d4533">&#9670;&#160;</a></span>~RBNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::~<a class="el" href="class_r_b_node.html">RBNode</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Checks if the key and value pointers are not null before deleting them. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acdfc053a89b7e3eecf5ea1d93b60d460" name="acdfc053a89b7e3eecf5ea1d93b60d460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfc053a89b7e3eecf5ea1d93b60d460">&#9670;&#160;</a></span>cascade()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::cascade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; *</td>          <td class="paramname"><span class="paramname"><em>nil</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes a node and all its children. </p>
<p>Deletes the node and all its children recursively. The nil node is passed as a parameter to avoid deleting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nil</td><td>The nil node of the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6db4aa6a00a85a2f73a6e3af6323782a" name="a6db4aa6a00a85a2f73a6e3af6323782a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db4aa6a00a85a2f73a6e3af6323782a">&#9670;&#160;</a></span>inorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::inorder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the inorder traversal of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to print, default is cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00233287e0c6b69900144aeea0e8fab6" name="a00233287e0c6b69900144aeea0e8fab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00233287e0c6b69900144aeea0e8fab6">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; * <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::min </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest node of the subtree rooted at this node. </p>
<p>Returns the smallest node of the subtree rooted at this node. The smallest node is the leftmost node in the subtree. If the left child is null, it returns this node. Time complexity is O(lg(size))</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the smallest node in the subtree rooted at this node </dd></dl>

</div>
</div>
<a id="a8b99d97ef8b4747bfc7a1cdc9fabf66f" name="a8b99d97ef8b4747bfc7a1cdc9fabf66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b99d97ef8b4747bfc7a1cdc9fabf66f">&#9670;&#160;</a></span>postorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::postorder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the postorder traversal of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to print, default is cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a497702bdad08496c307e538fbaa2f1eb" name="a497702bdad08496c307e538fbaa2f1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497702bdad08496c307e538fbaa2f1eb">&#9670;&#160;</a></span>predecessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; * <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::predecessor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the predecessor of the node. </p>
<p>Returns the predecessor of the node. The predecessor is the largest node in the left subtree. If the left child is null, it returns nullptr. Time complexity is O(lg(size))</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the predecessor node, or nullptr if the left child is null </dd></dl>

</div>
</div>
<a id="a09b21a1c9b6cd5e98eed5339cefee6aa" name="a09b21a1c9b6cd5e98eed5339cefee6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b21a1c9b6cd5e98eed5339cefee6aa">&#9670;&#160;</a></span>preorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::preorder </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the preorder traversal of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to print, default is cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4d79602d5ae78941178669947634126" name="af4d79602d5ae78941178669947634126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d79602d5ae78941178669947634126">&#9670;&#160;</a></span>printk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::printk </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the K smallest elements of the subtree rooted at this node. </p>
<p>Prints the K smallest elements of the subtree rooted at this node. The function is called recursively on the left and right children. Time complexity is O(k + lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The number of elements to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ec8e7b69ad9f75c51785630701d01dd" name="a0ec8e7b69ad9f75c51785630701d01dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec8e7b69ad9f75c51785630701d01dd">&#9670;&#160;</a></span>printNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::printNode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the node's key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to print, default is cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acecf6a080a7480fdce09e79fb3fada21" name="acecf6a080a7480fdce09e79fb3fada21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecf6a080a7480fdce09e79fb3fada21">&#9670;&#160;</a></span>searchNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt; * <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::searchNode </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the subtree rooted at this node for the node with key k. </p>
<p>Performs a DFS search for the node with key k. If the key is found, it returns a pointer to the node. Otherwise, it returns nullptr. Time complexity is O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node with key k, or nullptr if the key is not found </dd></dl>

</div>
</div>
<a id="a91795a969ff5f24d7a07cbde4fde5d2a" name="a91795a969ff5f24d7a07cbde4fde5d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91795a969ff5f24d7a07cbde4fde5d2a">&#9670;&#160;</a></span>searchValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">valueType * <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::searchValue </td>
          <td>(</td>
          <td class="paramtype">keyType</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for the node with key k and returns a pointer to the value. </p>
<p>Performs a DFS search for the node with key k. If the key is found, it returns a pointer to the value of the node. Otherwise, it returns nullptr. Time complexity is O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the value of the node with key k, or nullptr if the key is not found </dd></dl>

</div>
</div>
<a id="a4fd4a3d39d4bfe6f4338ee333ea5cf07" name="a4fd4a3d39d4bfe6f4338ee333ea5cf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd4a3d39d4bfe6f4338ee333ea5cf07">&#9670;&#160;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename keyType, typename valueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">keyType <a class="el" href="class_r_b_node.html">RBNode</a>&lt; keyType, valueType &gt;::select </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Kth smallest element in the subtree rooted at this node. </p>
<p>Returns the Kth smallest element in the subtree rooted at this node. The function is called recursively on the left and right children. Time complexity is O(lg(size))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The index of the smallest element to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/jace/Documents/GitHub/CPP-Structs-Algorithms/<a class="el" href="datastructs_8hpp_source.html">datastructs.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_r_b_node.html">RBNode</a></li>
    <li class="footer">Generated on Mon Apr 28 2025 04:03:35 for CPP-Structs-Algorithms by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
